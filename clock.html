<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Current Time Clock with Flip Animation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }

        .content-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16 / 9;
        }

        #myCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div class="content-container">
    <canvas id="myCanvas" width="800" height="450"></canvas>
</div>

<script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    const backgroundImage = new Image();
    backgroundImage.src = 'images/clock.png'; // Updated path for your background image
    const numberImages = {};
    for (let i = 0; i <= 9; i++) {
        const img = new Image();
        img.src = `images/${i}.png`; // Updated path for your number images
        numberImages[i] = img;
    }

    function getCurrentTime() {
        const now = new Date();

        const days = now.getDate();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();

        return { days, hours, minutes, seconds };
    }

    function updateDisplay(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

        const timeStrings = [
            String(time.days).padStart(2, '0'),
            String(time.hours).padStart(2, '0'),
            String(time.minutes).padStart(2, '0'),
            String(time.seconds).padStart(2, '0')
        ];

        const positions = [
            { x: 200, y: 220 }, { x: 235, y: 220 }, // Days
            { x: 300, y: 220 }, { x: 335, y: 220 }, // Hours
            { x: 400, y: 220 }, { x: 435, y: 220 }, // Minutes
            { x: 500, y: 220 }, { x: 535, y: 220 }  // Seconds
        ];

        timeStrings.forEach((timeString, index) => {
            for (let charIndex = 0; charIndex < timeString.length; charIndex++) {
                const char = timeString[charIndex];
                const posX = positions[index * 2 + charIndex].x;
                const posY = positions[index * 2 + charIndex].y;
                ctx.drawImage(numberImages[char], posX, posY, 30, 75);
            }
        });

        // Apply flip animation only to the last seconds digit
        animateFlipEffect(time.seconds);
    }

    function animateFlipEffect(seconds) {
        const animationDuration = 50; // 50ms flip animation
        let startTime = null;

        function flip(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;

            // Scale from 1 to a minimum of 0.2 to avoid complete shrinking
            const progress = elapsed / animationDuration;
            const scaleY = Math.max(0.2, Math.abs(Math.cos(progress * Math.PI))); // Use cosine for smooth flipping

            // Save the context before applying any transformations
            ctx.save();

            // Apply flip animation to the seconds (last digit)
            const digitToFlipIndex = 7; // The last digit (seconds unit)
            const posX = 535; // X position of the last seconds digit
            const posY = 220; // Y position of the last seconds digit

            // Clear the specific area of the digit
            ctx.clearRect(posX, posY, 30, 75);

            // Fix the background source coordinates
            const offsetX = 0; // No horizontal adjustment needed
            const offsetY = -30; // Adjusted further by -30 to pull from a lower portion of the background

            // Redraw the exact portion of the background behind the digit
            ctx.drawImage(
                backgroundImage,            // Image source
                posX, posY - offsetY,       // Source x, y from the background image (adjusted lower)
                30, 75,                     // Width and height to pull from the background image
                posX, posY,                 // Destination x, y on the canvas
                30, 75                      // Width and height on the canvas
            );

            // Apply the flip to the specific digit only
            ctx.translate(posX + 15, posY + 37.5); // Move to the center of the digit
            ctx.scale(1, scaleY); // Apply vertical scale to create flip effect
            ctx.translate(-(posX + 15), -(posY + 37.5)); // Move back after scaling

            // Draw the digit being flipped with the scaled transformation
            ctx.drawImage(numberImages[seconds % 10], posX, posY, 30, 75);

            // Restore the context after the transformations
            ctx.restore();

            if (elapsed < animationDuration) {
                requestAnimationFrame(flip); // Continue the animation
            } else {
                // Ensure the final number is restored to full size (scaleY = 1)
                ctx.save();
                ctx.clearRect(posX, posY, 30, 75); // Clear the flipped number area
                ctx.drawImage(
                    backgroundImage, 
                    posX, posY - offsetY,     // Source x, y from the background image (adjusted lower)
                    30, 75,                   // Width and height to pull from the background image
                    posX, posY,               // Destination x, y on the canvas
                    30, 75                    // Width and height on the canvas
                ); 
                ctx.drawImage(numberImages[seconds % 10], posX, posY, 30, 75); // Draw the new number at full size
                ctx.restore();
            }
        }

        requestAnimationFrame(flip); // Start the animation
    }

    function startClock() {
        let prevSeconds = null;

        setInterval(() => {
            const time = getCurrentTime();
            if (time.seconds !== prevSeconds) {
                updateDisplay(time);
                prevSeconds = time.seconds;
            }
        }, 1000);
    }

    backgroundImage.onload = () => {
        const time = getCurrentTime();
        updateDisplay(time);
        startClock();
    };
</script>

</body>
</html>
